/*
  SWITCHBOT CON EL ESP32C3 SUPERMINI
  version: 0.0.1
*/

/*
   SWITCHBOT
   
   To compile this code using RemoteXY library 4.1.4 or later version 
   download by link http://remotexy.com/en/library/
   To connect using RemoteXY mobile app by link http://remotexy.com/en/download/                   
     - for ANDROID 4.16.02 or later version;
     - for iOS 1.13.1 or later version;
    
   To interact with the GUI, please refer to the manual: 
   https://remotexy.com/ru/help/code/interaction/

   This source code was automatically generated by the RemoteXY editor and 
   is an example for the RemoteXY library. 
   Licensed under the MIT License. See the LICENSE file in the RemoteXY library
   root (https://github.com/RemoteXY/RemoteXY-Arduino-library) for full license 
   details.             
*/

//////////////////////////////////////////////
//        RemoteXY include library          //
//////////////////////////////////////////////

// you can enable debug logging to Serial at 115200
//#define REMOTEXY__DEBUGLOG    

// RemoteXY select connection mode and include library 
#define REMOTEXY_MODE__ESP32CORE_BLE

#include <BLEDevice.h>

// RemoteXY connection settings 
#define REMOTEXY_BLUETOOTH_NAME "RemoteXY"


#include <RemoteXY.h>

// RemoteXY GUI configuration  
#pragma pack(push, 1)  
uint8_t RemoteXY_CONF[] =   // 78 bytes
  { 255,2,0,0,0,71,0,19,0,0,0,83,119,105,116,99,104,66,111,116,
  99,105,116,111,0,31,1,106,200,1,1,2,0,2,19,21,62,34,0,40,
  26,31,31,79,78,0,79,70,70,0,1,16,67,76,76,0,40,31,67,97,
  109,98,105,97,114,32,79,114,105,101,110,116,97,99,105,111,110,0 };
  
// this structure defines all the variables and events of your control interface 
struct {

    // input variables
  uint8_t switch_1; // =1 if switch ON and =0 if OFF, from 0 to 1
  uint8_t changeOrientation; // =1 if button pressed, else =0, from 0 to 1

    // other variable
  uint8_t connect_flag;  // =1 if wire connected, else =0

} RemoteXY;   
#pragma pack(pop)
 
/////////////////////////////////////////////
//           END RemoteXY include          //
/////////////////////////////////////////////

/**** BIBLIOTECAS ****/
#include <ESP32Servo.h>

/**** DEFINICION DE PINES ****/
#define btn0  4 // pin del boton
#define pinR  0 // pin del led rojo
#define pinG  1 // pin del led verde
#define pinB  2 // pin del led azul
//#define pinEna   NaN // pin para habilitar la alimentacion del servo
#define pinSm 3 // pin para la se√±al pwm del servo
#define TIME_TO_SLEEP 5000

/**** OBJETOS A USAR ****/
Servo servoMotor;

/**** VARIABLES GLOBALES ****/
bool state = false; // estado del switchbot, true:on, false:off
const int ANGLE_1 = 0;
const int ANGLE_2 = 180;
int ANGLE_ON  = ANGLE_1;
int ANGLE_OFF = ANGLE_2;
int counter = 0;
bool sleep_mode = false;

/**** FUNCIONES A USAR ****/
void parpadeo(int pin, int times = 3, int millis = 500) {
  for (int i = 0; i < times; i++) {
    digitalWrite(pin, HIGH);
    RemoteXY_delay(millis);
    digitalWrite(pin, LOW);
    RemoteXY_delay(millis);
  }
}
void configurarSwitchbot() {
  // configuramos los pines de entrada y salida
  pinMode(btn0, INPUT);  // el boton es una entrada
  pinMode(pinR, OUTPUT); // los led son salidas
  pinMode(pinG, OUTPUT);
  pinMode(pinB, OUTPUT);
  // pinMode(pinEna, OUTPUT);
  servoMotor.attach(pinSm); // pinSm como salida pwm para el servo
}
void cambiarOrientacion() {
  Serial.println("Cambiando Orientacion...");
  if (ANGLE_ON == ANGLE_1) {
    ANGLE_ON  = ANGLE_2;
    ANGLE_OFF = ANGLE_1;
  } else {
    ANGLE_ON  = ANGLE_1;
    ANGLE_OFF = ANGLE_2;
  }
  parpadeo(pinB, 3, 250);
}
void cambiarEstado(bool new_state) {

  // cambiamos el estado a on o off
  state = new_state;
  int led, angle;
  if (state) {        // true - prender
    led = pinG;
    angle = ANGLE_ON;
    Serial.println("prendiendo...");
  } else {            // false - apagar
    led = pinR;
    angle = ANGLE_OFF;
    Serial.println("apagando...");
  }
  digitalWrite(led, HIGH);
  servoMotor.write(angle);
  RemoteXY_delay(1500);
  digitalWrite(led, LOW);
}
// funcion para saber si se mantiene presionado por x tiempo el boton
bool es_presionado(int wait_time) {
  int counter = 0;
  while (digitalRead(btn0)) {
    if (counter >= wait_time) {
      return true;
    }
    counter += 25;
    RemoteXY_delay(25);
  }
  return false;
}

/**** FUNCIONES PRINCIPALES ****/
void setup() {
  Serial.begin(115200);
  delay(500);
  RemoteXY_Init ();
  configurarSwitchbot();
  // digitalWrite(pinEna, HIGH);
}
void loop() {

  RemoteXY_Handler ();
  Serial.print(" switch: ");
  Serial.print(RemoteXY.switch_1);
  Serial.print(" changeOrientation: ");
  Serial.println(RemoteXY.changeOrientation);

  if (state != RemoteXY.switch_1) {
    state = RemoteXY.switch_1;
    cambiarEstado(state);
  }
  Serial.println(digitalRead(btn0));
  if (digitalRead(btn0)) {
    state = !state;
    RemoteXY.switch_1 = state;
    cambiarEstado(state);
  }
  if (RemoteXY.changeOrientation) {
    cambiarOrientacion();
    RemoteXY_delay(200);
  }

  // if (digitalRead(btn0)) {
  //   if (es_presionado(5000)) {
  //     // cambiamos orientacion
  //     cambiarOrientacion();
  //   } else {
  //     // cambiamos el estado
  //     cambiarEstado(!state);
  //   }
  // }
  // if (sleep_mode == false) {
  //   if (counter <= TIME_TO_SLEEP) {
  //     counter += 250;
  //   } else {
  //     digitalWrite(pinEna, LOW);
  //     sleep_mode = true;
  //   }
  //   Serial.println(counter);
  // }
  //delay(250);
  RemoteXY_delay(100);
}
